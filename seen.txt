فصل اول - شروع
کل فصل ۱ نکاتی که داشت رو نوشتم و دیدن دوباره اش وقت کشی ۱۰۰ درصد هست. برای یادگیری دیگه نبینم و همین پایینی ها رو بخونم و
خودم ور برم کافیه یا اگه لازم بود از اینجا فقط با کنترل اف سرچ کنم و پیدا کنم یا از اینترنت. اما دیدن دوباره فیلم تاکید 
میکنم وقت کشی هست.
1- سرعت پخش فیلم ها
2- مقدمه
3- پشتیبانی
4- چطوری از گیت استفاده کنیم
5- نصب گیت و vscode
6- چک کردن نصب گیت
تو لینوکس و مک، کامند + اسپیس سرچ رو باز میکنه. برای دیدن ورژن git --version رو میزنیم.
7- تنظیمات گیت
(این دستور رو نزنم. تا آخر بخونم بعد) برای دیدن تنظیماتی که تا حالا انجام شده، دستور git config --global -e رو میزنیم.
اما تو ادیتور vim که واقعا افتضاحه و دکمه backspace توش کار نمیکنه. خروج نداره، نمیشه تایپ کرد و غیره. برای این که ادیتور
رو عوض کنیم، قبل از این دستور میتونیم بنویسیم git config --global core.editor "code --wait" که بعد از
این با vscode بازش کنه و بشه مثل بچه آدم تغییرش داد. git config --global core.autocrlf true رو توی ویندوز مینویسیم و
git config --global core.autocrlf input رو توی مک و لینوکس مینویسیم که تنظیمات گیت برای تمام سیستم عامل ها یکپارچه بشه. 😒
حالا میتونم دستور git config --global -e رو بزنم که تنظیماتش رو ببینم. احتمالا e اول کلمه edit رو برداشتن.
8- استفاده از ترمینال قسمت 1
 با دستور touch yechizi.txt میشه یه فایل خالی ساخت تو ترمینال git bash. ولی تو cmd فرق داره. با دستور rm esme_file میتونیم
 پاکش کنیم. با clear هم تمیز میشه. البته تو cmd باید cls رو نوشت.
9- استفاده از ترمینال قسمت 2
ساخت دایرکتوری با دستور mkdir test هست. با cd میشه جابه جا شد. برای پاک کردن فولدر دستور rm جواب نمیده. باید بنویسیم
rmdir esme_directory تا پاک شه. البته اگه داخلش فایل باشه میگه که داخلش فایل هست و اول اون ها رو پاک کن بعد. اما میشه
دستور rm -rf esme_directory زد که خطرناکه و به طور ریکرسیو هر چی داخلش هست رو پاک میکنه. تو ریسایکل بین هم نمیره.
10- استفاده از ترمینال قسمت 3
با دستور echo میشه یه چیزی رو پرینت کرد. اگه چند تا کلمه باشن داخل دابل کوتیشن مینویسیم. برای ریختنش تو فایل با علامت بزرگتر
این کار رو میکنیم. اما پاک میکنه و append نمیکنه. برای append کردن دو تا علامت بزرگتر پشت سر هم میذاریم. متن داخل کوتیشن
هم نوشتم کار کرد و بدون کوتیشن هم حتی کار کرد. ولی حواسم باشه که عادت نکنم و بهتره که بذارم دابل کوتیشن رو. چون همه جا
کار نمیکنه. برای کپی کردن فایل، از دستور cp استفاده میکنیم. فایل مبدا و بعد فایل مقصد. برای انتقال از دستور mv استفاده
میکنیم. باز هم از مبدا به مقصد که مقصد فولدر هست. البته میتونیم اسم فایل هم بذاریم که در این صورت در حین انتقال، اسم فایل
رو هم عوض میکنه. یعنی اطلاعات داخل فایل قبلی ها میمونه، اما اسمش عوض میشه. که خب از همین برای تغییر نام یک فایل در پوشه
فعلی هم میشه استفاده کرد. برای دیدن همه فایل ها و فولدرها دستور ls. برای دیدن با جزییات بیشتر ls -a و برای دیدن جزییات
واقعی از ls -al استفاده میکنیم که میگه کی ساخته. کِی ساخته. سطح دسترسیش چیه. برای دیدن کارنت دایرکتوری هم دستور pwd
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل دوم - گیت مقدماتی
11- روند ذخیره تغییرات در گیت به چه صورت هست؟
توضحات جالبی بود. برای خودم دیگه به درد نمیخوره. اگه بخوام دوره بسازم میتونم ازش ایده بگیرم.
12- گیت چطوری گذشته رو ذخیره میکنه؟
13- مبحث git snapshot
14- مبحث staging area
15- بریم دست به کد بشیم!
16- نحوه کامیت کردن و برسی لاگ ها
17- دستور git add
18- صورت تمرین مرور مباحث
19- پاسخ ویدئویی تمرین به همراه نکات
از اول فصل ۲ تا اینجا به کار خودم خیلی نمیاد. جالب و مفهومی بود. اما برای گفتن به بقیه. برای خودم چیز جدیدی نداشتن.
20- امکان oneline و reverse
با دستور git log --oneline میتونیم دیگه اطلاعات جزیی رو نگیریم و راحت تر به لاگ ها دسترسی داشته باشیم.
با دستور git log --reverse هم میتونیم کامیت ها رو برعکس ببینیم. یعنی اولین کامیت رو اول نشون میده. همزمان هم میشه
هر دو تا رو نوشت و ترتیبشون هم فرقی نداره.
21- سوییچ های -a و -m در کامند کامیت
خیلی مهم نیست. اما اگه فایلی رو تغییر دادیم و میخوایم با یه دستور هم اضافه اش کنیم به stage area و هم فوری بعدش
کامیت بزنیم، میتونیم بنویسیم git commit -a -m "peygham" که خودش اول همه فایل های تغییر یافته رو به استیج اضافه میکنه
و با پیغامی که نوشتیم کامیت هم میکنه. میشه به طور خلاصه تر git commit -am "peygham" هم نوشت. نکته ای که داره فایل های
جدید رو اضافه نمیکنه. یعنی برای این که فایل های تغییر داده شده رو یه کامیت برای تغییراتشون بزنیم خوبه. برای فایل هایی
که بخوایم اضافه کنیم جداگانه باید git add رو بنویسیم.
22- اصول نوشتن کامیت ها
نکته ای که داشت، وقتی گیت کامیت خالی بدون -m میزد، تو vscode بعد از خط اول، ۲ تا اینتر زد و چیزهایی که نوشت اونا دیگه
نیومدن. در واقع بدنه کامیت هستن که توضیحات طولانی رو میشه اونجا نوشت که حالت عادی وقتی گیت لاگ میزنیم اذیت نکنه. اما
توضیح بیشتری راجع به اون کامیت اگه داریم میشه نوشت.
23- حذف فایل کامیت شده از پروژه
24- دستور git rm
وقتی یه فایلی رو پاک میکنیم، برای این که به گیت هم بفهمونیم بعدش باید بگیم git add esme_file که گیت بفهمه پاک شدن اون
فایل حالت جدیدی از استیجینگ اریا هست و بعد کامیتش کنیم. حالا اگه بخوایم خود گیت یه فایلی رو پاک کنه و به استیجینگ اریا
هم ببره، میتونیم این ۲ تا مرحله رو یکی کنیم. یعنی به جای این که فایل رو پاک کنیم و بعد بنویسیم git add file_e_paak_shode
به جاش تو یه مرحله مینویسیم git rm esme_file و این طوری خودش فایل رو پاک میکنه و به استیجینگ اریا هم میره. یعنی لازم نیست
دیگه برای اون فایل git add رو بنویسیم و یه مرحله کوتاه تر میشه. اما کامیت نمیکنه. چون شاید بخوایم اون فایل رو برگردونیم
و یا بخوایم تغییرات دیگه رو هم همراه با اون کامیت اعمال کنیم.
25- الگو در انتخاب فایل ها
جالب بود. در مورد کار با فایل ها و آدرس دهی بود. رو اونا مسلط بشم اینم حله. نکته جدیدی از گیت نداشت. مثل همون نامگذاری
فایل ها اینا هست که مثلا *.txt یعنی همه فایل های با پسوند txt در فولدر فعلی و یا */*/*.txt یعنی همه فایل ها با پسوند txt
در این فولدر و فولدرهای داخلیش و فولدرهای داخلی اونها.
26- حذف از ایندکس
جالب بود. برای درک مفهومی بهتر خوب بود. ولی خیلی هم خاص نبود و نکته ای نداشت.
27- نظر شما
28- تغییر نام با git mv
وقتی یه فایلی رو rename میکنیم، برای شناسوندن به گیت، باید بهش بگیم پاک کردن یک فایل رو به استیجینگ اریا اضافه کنه و ساخته
شدن فایل جدید رو هم به استیجینگ اریا اضافه کنه و دو تا فایل رو باید اضافه کنیم. بعد خودش با توجه به محتویات متوجه میشه که
عملی که انجام دادیم rename هست. برای راحتی کار میتونیم به گیت بگیم rename کنه که دیگه ما هم زیاد ننویسم. مثلا برای تغییر نام
فایل 1.txt به 2.txt میشه نوشت git mv 1.txt 2.txt که خودش رینیم میکنه و چون تو استیجینگ اریا بود، کافیه کامیتش کنیم بعد.
اگه از طریق سیستم عامل یک فایل رو rename کنیم که خب با دستور گیت انجام ندادیم و اونجا باید دو تا رو جداگانه add کنیم یا اگه
میشد با git add . یا git add *.py و این جور چیزا اضافه کنیم.
29- درک wd و sa و repo
wd ورکینگ دایرکتوری هست. sa استیجینگ اریا و repo هم ریپازیتوری. از نظر مفهومی خیلی ویدیو خوب و پرباری بود. خیلی جالب بود و
واقعا عالی توضیح داد. مجدد هم ببینم حتما فایده داره. هیچ کدی نزد و فقط توضیح بود. اما توضیح مفهومی و عالی تفاوت های حالت های
ترک نشده و استیج شده و کامیت شده.
30- دستور git status -s
خیلی توضحات باحالی داشت و جالب بود. اینجا دیگه نمینویسم باید کار کنم باهاش تا دستم بیاد. دیدن دوباره ویدیو هم بد نیست. اما
کار کردن با این دستور هست که باعث میشه خوب یاد بگیرم.
31- دستور مهم git diff
این ویدیو و بعدی، راجع به دستور git diff بود. با دستور git diff، تفاوت تمام فایل های تغییر یافته رو در ورکینگ دایرکتوری با
استیجینگ اریا بهمون میگه. اگه بخوایم برای یه فایل خاص رو ببینیم اسمش رو هم مینویسیم مثلا git diff test.py که تفاوت تمام فایل ها
رو دیگه نمیده. فقط همون فایل که ورکینگ دایرکتوری با استیجینگ اریا چه فرقی داره. تو ویدیو بعدی میگه که اگه بخوایم تفاوت
استیجینگ اریا با ریپازیتوری رو ببینیم از git diff --staged استفاده میکنیم که اگه فایل رو ننویسیم تفاوت تمام فایل های استیجینگ
اریا با ریپازیتوری رو میده و اگه بنویسیم فقط همون مورد رو.
32- دستور diff برای stage
33- عملیات git diff در vscode
راجع به کار کردن با قسمت سورس کنترل وی اس کد گفت که جالب بود. نوشتن خیلی فایده نداره. کار کنم دستم بیاد بهتره.
34- درخواست
35- نکته مهم difftool
36- تنظیمات difftool
این تغییرات رو انجام ندادم. به صورت پیش فرض vscode خودش تو قسمت سورس کنترل دائم git status رو اجرا میکنه و میتونیم به صورت
گرافیکی تغییرات تمام فایل ها رو ببینیم که خودم هم استفاده میکنم. حتی git diff --staged رو هم میشه از همون قسمت دید. اما این
ابزار difftool در vscode برای الان هست. ما با دستور git diff یا git diff --staged میتونیم مثلا ببینیم که فایلمون توی ۱۰۰ کامیت
قبل با ۱۰۲ کامیت قبلی چه تفاوتی داره. تو تنظیماتی که اینجا انجام داد، میتونیم بهش بگیم که ابزار پیش فرض نمایش diff وی اس کد
باشه که بعد وقتی بهش گفتیم vim و اینا رو باز نکنه برامون. کلا خیلی کم استفاده میشه همچین چیزی. اما خب به هر حال این توضیحات
رو نوشتم که بدونم چی هست. در حال حاضر باز هم به سیستمم اعمال نکردم.
37- دستور مهم git restore
جالب بود. توضیح git restore --staged بود که دقیقا برعکس git add هست. چیزی رو که به حالت staged بردیم برمیگردونه به حالت
unstaged و دستور git restore خالی که چیزی رو که تغییر دادیم و هنوز stage نشده رو میتونیم برگردونیم به حالت قبل از تغییرات
یعنی آخرین ورژن کامیت شده فعلی. جالب بود. با تمرین کردن بود که متوجه شدم چه طوری کار میکنه. اما دیدن فیلم هم بد نیست. حالا اگه
یه فایلی رو جدید اضافه کنیم، با git restore --staged میشه برش گردوند به حالت unstaged. اما دستور git restore روش کار نمیکنه.
چون تازه ایجاد شده و این فایل آخرین کامیت نداره. خوشبختانه دستور git restore باعث نمیشه که اون فایل پاک بشه. گیت کلا اون رو
ترک نمیکرده. اگه بخوایم فایل های اضافه رو پاک کنیم میشه از دستور git clean استفاده کرد که فایل های untaracked رو پاک میکنه.
منتهی خودش به ما هشدار میده. fatal. چون احتمالا با دستور rm سیستم میاد پاکش میکنه و دیگه قابل برگشتن نیست، به ما ارور میده
میگه که با هیچ آپشنی استفاده نکردی. مثلا میتونیم با -f بزنیم که git clean -f دیگه میاد هر چی آنترکد هست رو پاک میکنه و دیگه
قابل برگردوندن نیست. در واقع git clean -f file_name مثل rm file_name عمل میکنه. git clean -i هم زدم جالب بود. آپشن میده که
کامل خودش توضیح میده. مثلا میتونیم همه رو انتخاب کنیم. یا موردی ازمون بپرسه. یا فایل ها رو به ما نشون بده و انتخاب کنیم و یا
این که پترن بهش بدیم. بقیه آسون بودم تست کردم و جالب بود. اما پترن رو نتونستم درست بدم. خلاصه جالب بود اما چون خیلی کاربردی
نبود پی اِش رو نگرفتم.
38- پشت پرده واقعی git restore
خیلی جالب نبود. خودش هم میگفت باعث گیج شدن میشه. با همون ویدیو قبلی که متوجه شدم و توضیحات خودم که نوشتم ادامه بدم.
39- تمرین restore
تمرین جالبی بود. restore رو بهتر درک کردم. توضیحاتشم خوب بود.
40- مفهوم HEAD
چیزی که فهمیدم اینه که HEAD در واقع یه اشاره گر هست به آخرین کامیتی که کردیم. میتونیم بهش بگیم ۲ تا قبلی یا ۳ تا قبلی.
تو فصل برنچ کامل تر توضیح داده.
41- مفهوم و کاربرد HEAD
42- استفاده از git restore و فلگ source--
خیلی ویدیو جالب و مهمی بود. وقتی ما مینویسیم git restore esme_file و به دستور restore ورودی نمیدیم، خودش مرجعش رو میذاره
HEAD. پس در واقع مرجع داره و دیفالتش HEAD هست. اما ما میتونیم تعیین کنیم. مثلا میتونیم بنویسیم git restore --source=x esme_file
که x شماره کامیتی هست که قبلا انجام دادیم. مثلا تو ۴۰ تا کامیت قبلی یه فایلی رو پاک کرده بودیم، میتونیم این طوری برش گردونیم
بدون این که بقیه چیزها به هم بریزه. البته دقت کنم برای فایلی هست که پاکش کرده بودیم. اگر اسم فایلی رو بنویسیم که هنوز وجود داره،
فایل اون موقع رو میاره به اینجا و استیجینگ اریا و انگار که خودمون دستی فایل جدید رو تغییر دادیم. بعد خودمون تصمیم میگیریم که
چیکار کنیم. نکته مهم هم این که دقت کنم. تست نکردم اما اگه یه فایلی رو تغییر بدم در حال حاضر و در حال ترک باشه و به استیجینگ اریا
اضافه اش نکرده باشم، و بعد این مدلی restore کنم از قدیمی ها، قاعدتا یکیش از بین میره. چون من از تو ورکینگ دایرکتوری روش یه
تغییراتی اعمال کردم و هنوز وارد استیجینگ اریا نکردم. پس اگه یکی از حالت های قدیمی رو restore کنم تغییرات امروز من از بین میره.
خلاصه این که موقع restore کردن حواسم باشه و دقت کنم. نکته مهم اینه که اگه فقط بنویسیم git restore --source=x و فقط شماره کامیت رو
بنویسیم و بعدش فایلی ننویسیم، ارور میده میگه مسیر ندادی. خودم git restore --source=x * نوشتم خودش تمام ساختار رو برگردوند به
اون حالت و خیلی ها پاک شدند (چون رفته بودم به اولین کامیت D:) تفاوتش با ریست کردن این بود که وقتی git log میگرفتم لاگ ها رو هم
بهم نشون میداد. با git restore --source=x * که این بار x آخرین کامیت فعلی بود، هیچی برنگشت D: زدم git restore --source=x */*
و این بار فولدرها و فایلهای داخلی برگشتن. اما فایل های دایرکتوری ای که توش گیت رو اجرا کرده بودم برنگشت و اونا رو دونه دونه باید
مینوشتم. اما با گیت ریست دش دش هارد همه برمیگشت. خلاصه. موقع کار باهاش دقت کنم. نکته آخر این که اگه شماره کامیت رو نخوایم بنویسیم،
میشه با استفاده از هد هم به چند کامیت قبلی برگشت. مثلا git restore --source=HEAD~5 file_name یعنی برو file_name رو از ۵ تا کامیت
قبل از HEAD بیار. علامتش منها نیست تیلدا هست. کار کنم یاد میگیرم این نوشتن ها خیلی فایده نداره.
43-مفهوم فایل های .keep
اگه بخوایم یه فولدری بسازیم که گیت دنبالش کنه اما در حال حاضر فایلی نداریم که بذاریم و نمیخوایم فایل اصلی ای رو بذاریم، رایجه
که داخل اون فولدر یه فایل به اسم .keep میذارن. یعنی فولدرمون رو بسازیم و داخلش فایل .keep خالی بذاریم همه گیت کارها میدونن که اون
فایل برای این هدف بوده. نکته خاص دیگه ای نداشت این فیلم. . هم اول اسم فایل ها باعث میشه که هیدن باشن.
44- رفع ارور ambiguous
گفت اگه جایی این ارور رو خوردیم که گیت نمیشناسه حالا به خاطر شبیه بودن اسم فایل یا فولدر یا سورس یا هر چی هست، با دو تا دش میتونیم
جدا کنیم که بهش کمک کنیم مثلا اگه git restore --source=HEAD~5 file1.py گیر داد که اسم فایل file1.py برای من ambiguous است، با
نوشتن git restore --source=HEAD~5 -- file1.py بهش میفهمونیم چیزایی که سمت چپ هستند فایل نیستند (سورس و چیزای دیگه هستند) و چیزایی
که سمت راست هستند اسم فایل هستند. گفت فقط اینجا و برای دستور restore نیست. همه جا در گیت اینطوری هست. کلش همین بود و نوشتم و لازم
نیست دیگه فیلم رو ببینم.
45- دستور alias و کاربرد آن
جالب بود. اگه بخوایم خودمون دستوری به گیت اضافه کنیم و کاستومایزش کنیم، میتونیم. مثلا خودش برای unstage کردن یه دستور ساخت و نوشت
git config --global alias.unstage "restore --staged" این کار باعث میشه که تو فایل تنظیماتش داخل قسمت alias نوشته بشه که هر وقت ما
تو گیت نوشتیم unstage خودش به جاش از restore --staged استفاده کنه. یعنی از الان به بعد تو گیت من میتونم بنویسم git unstage file_name
و این طوری فایلی که تو حالت staged هست برمیگرده به حالت unstaged. خودم دستی تو فایلش اسم unstaged رو عوض کردم گذاشتم haghdashdefo
D: و دیدم که کار میکنه یعنی نوشتم git haghdashdefo file2.txt و فایلی که تو حالت staged بود رو به حالت unstage برد. خلاصه این که
خودمون میتونیم دستورات جدید برای راحتی کار تعریف کنیم. من برگردوندم به همون unstage و رو سیستم من هست. اما خودش گفت که تو دوره
استفاده نمیکنه. ولی چیز جالبی بود. alias های دیگه ای که ساختم. goal برای log --graph --oneline --all و oal برای log --oneline --all
46- دانلود فایل تمرین
47- تمرین restore
48- دستور git amend
اگه یه کامیتی کردیم اما یادمون اومد که یه تغییرات دیگه ای هم با این کامیت بوده و نمیخوایم کامیت جدا بزنیم، میتونیم
از دستور git commit --amend استفاده کنیم که روی آخرین کامیت دوباره کامیت میکنه. ما رو وارد ادیتور میکنه که یه پیغام براش بذاریم.
میتونیم با git commit --amend -m "peygham" همونجا بگیم و دیگه ما رو وارد ادیتور نکنه. و یا اگه پیغامش رو نمیخوایم عوض کنیم میتونیم 
از سوییچ --no-edit استفاده کنیم و بنویسیم git commit --amend --no-edit که دیگه پیغام جدید ندیم و وارد ادیتور هم نکنه ما رو. اما روی
همون کامیت قبلی اعمال کنه و کامیت جدید نسازه.
نکته مهم اینه که امند، دوباره کامیت میکنه و هشش هم عوض میشه. پس اگه لوکال بودم و همون لحظه خواستم تغییر بدم و کس دیگه ای به من وابسته
نبود میتونم استفاده کنم. در غیر این صورت ممکنه برای بقیه مشکل پیش بیاد.
49- دستور git show
با نوشتن git show commit_hash میتونیم ببینیم که تو یه کامیت چه تغییراتی رخ داده بود و چه زمانی بود و کی کامیت کرده بود. میتونیم بعدش
یه : هم بذاریم و بگیم که یه فایل خاص رو به ما نشون بده. مثلا git show 35x83s6:seen.txt که میاد فایل seen.txt اون کامیت رو به ما نشون میده.
50- دستور ls-tree
برای لیست کردن ساختار درختی پروژه با دستور git ls-tree commit_hash میتونیم ببینیم ساختار درختی پروژه در اون کامیت چه شکلی بوده.
مثلا git ls-tree head نشون میده که الان ساختار پروژه چه شکلی هست. و git ls-tree head~10 نشون میده که ساختار ۱۰ تا کامیت قبلی چه شکلی بوده.
خلاصه میتونیم هش شده کامیت رو هم بهش بدیم و ساختار اون زمان رو به ما میده. تو جوابی که میاره، اولش ۶ تا رقم هست که احتمالا همون سطح دسترسی
فایل یا فولدر هست. بعدش کلمه blob یا tree رو مینویسه. blob یعنی که اونی که جلوشه و در ادامه مینویسه فایل بوده و tree یعنی خودش یه ساختار
درختی دیگه داره. بعد از اون هش شده اون فایل یا اون درخت رو در اون زمان مینویسه. و اگه بخوایم ریزتر بررسیش کنیم، مثلا بخوایم ببینیم که یه
پوشه خاص چه فایل هایی داشته، میتونیم اون هش رو برداریم و دوباره بنویسیم git ls-tree oon_hashi_ke_copy_kardim و این طوری ساختار اون پوشه
رو به ما نشون میده و همین طوری میشه ادامه داد. در آخر هم اسمش رو مینویسه که blob بوده یعنی اسم فایل هست و اگه tree بوده یعنی اسم دایرکتوری
هست و ما میتونیم به این روش اسم فولدر یا فایلهایی که تو ۴۰ تا کامیت قبلی وجود داشتند و بعد پاک شدند رو هم پیدا کنیم و اگه لازم بود اونها
رو restore کنیم.
51- ساختار ذخیره فایل
طولانی و زیاد بود و فکر نکنم خیلی مهم باشه. با git ls-files، تمام فایل های ترک شده رو نشون میده و کلی آپشن داره. بنویسم git ls-files -h
هلپش رو میاره و اگه لازم شد همون موقع ازش استفاده کنم.
52- فایل .gitignore
لینک https://github.com/github/gitignore/tree/main رو معرفی کرد که فایل های گیت ایگنور برای پروژه های مختلف روش هست.
53- نکته مهم ignore کردن فایل های کامیت شده
اگه فایلی رو از قبل اضافه کردیم و گیت داره اون رو ترک میکنه، حالا اگه به گیت ایگنور اضافه اش کنیم باز هم گیت تغییراتش رو ثبت و کامیت هم
میکنه. برای این که دیگه این کار رو نکنه از دستور git rm --cached esme_file دقت کنم که اگه --cached رو نذارم هم از تو استیجیگ اریا ورمیداره
و هم دستور rm رو روش اجرا میکنه و فایل پاک میشه. اما با --cached از استیجینگ اریا ورمیداره اما فایل رو از ورکینگ دایرکتوری پاک نمیکنه.
54- دانلود فایل تمرین
55- تمرین جذاب و امنیتی gitignore
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل سوم - گیت پیشرفته
56- مقدمه فصل
57- دانلود فایل فصل
58- سناریو پروژه واقعی
59- امکانات stat و patch
فلگ --stat توی دستور git log استفاده میشه و میگه که هر فایلی چند خطش کم و چند خطش زیاد شده. فلگ --patch هم با git log استفاده میشه و
خطوط تغییر یافته رو بهمون نشون میده. همزمان هم میشه از هر دو تا استفاده کرد. موقع کار کردن با کامند لاین، علامت - منظور قبل از تغییرات
و علامت + منظور بعد از تغییرات است. همچنین حرف a قبل از اسم فایل یعنی قبل از تغییرات و b یعنی بعد از تغییرات. مثلا a/test.txt و b/test.txt
یعنی a حالت قبلی فایل test.txt رو نشون میده و b حالت بعدی رو.
60- امکانات after و before
git log --author="Mohammad" همه کامیت هایی رو میاره که نویسنده شون توشون کلمه Mohammad به کار رفته.
git log --after="yesterday" تمام کامیت های بعد از دیروز رو میاره.
git log --before="yesterday" تمام کامیت های قبل از دیروز رو میاره.
git log --after="one week ago" تمام کامیت های بعد از هفته قبل رو میاره.
git log --after="2023-11-16" تمام کامیت های بعد از تاریخ رو میاره.
مهم دونستن after و before ایناست. سرچ کنم حله.
61- سرچ کردن در لاگ
git log --grep="harchizi" کامیت هایی رو پیدا میکنه که داخل متن کامیتشون کلمه harchizi به کار رفته.
git log -S"find_a_text" جدا از متن کامیت، داخل خود فایل ها هم جاهایی که find_a_text تغییر کرده رو پیدا میکنه و شماره کامیت هاش رو به
ما میده.
برای محدود کردن قسمتی که گیت لاگ میکنه، محدوده رو با شماره کامیت و .. بهش میدیم. مثلا
git log HEAD~5..HEAD~1 یعنی کامیت های ۵ تا مونده به آخر تا یکی مونده به آخر رو بررسی کن. حالا میتونیم بقیه فلگ ها رو هم رو همون محدوده
بهش بگیم که اعمال کنه.
62- جداسازی اسم برای سرچ log
بعضی وقتا که گیت ارور ambiguous میده و نمیدونه که ما اسم فایل نوشتیم یا فلگ هست، فلگ ها رو ابتدا همه رو مینویسیم. کارمون که تموم شد با 
 -- جدا میکنیم و بعد از اون اسم فایل رو مینویسیم. مثلا با دستورات زیر میتونیم ببینم برای فایل a چه تغییراتی رخ داده.
git log --oneline -- a
git log --oneline --stat -- a
git log --oneline --stat -- patch -- a
در حالی که اگه -- رو نذاریم بهمون ارور میده و میگه که a مبهم هست.
63- دستور pretty در لاگ
برای لاگ کردن میتونیم کاستومایز کنیم که چه طوری بهمون نشون بده. مثلا git log --pretty=format"%an %h"
یعنی اسم نویسنده کامیت author name و هش شده کامیت ورژن کوتاهش که ۷ تایی هست رو به ما نشون بده. h
اگه H بزرگ بذاریم هش شده کامل رو مینویسه. %cd کامیت دیت رو مینویسه. %ae ایمیل نویسنده هست. و ... که ارزش نوشتن نداره. تو گوگل سرچ کنم
فقط این که رنگیش هم کرد و اگه میخوام زیاد باهاشون کار کنم قاعدتا بهتره براشون alias تعریف کنم.
64- دستور shortlog
65- تغییرات بین دو کامیت
git diff HEAD~3 HEAD کل تغییرات رو بین این دو تا کامیت نشون میده. کامیت های وسط رو کار نداره. تغییراتی که در نهایت بین این ۲ کامیت اعمال
شده رو نشون میده. میتونیم ببینیم فقط چه فایل هایی تغییر کردند با دستور git diff HEAD~3 HEAD --name-only اسم فایل ها رو میده.
git diff HEAD~3 HEAD name--status میگه که چه طوری عوض شدن. که اضافه شده. کی پاک شده و کی تغییر کرده.
66- نمایش یک فایل خاص در گذشته
git show HEAD~7:a.txt نشون میده که تو ۷ تا کامیت قبلی داخل فایل a.txt چی بوده. اگه مثلا وجود نداشته باشه هم که مینویسه وجود نداره. اما اگه
باشه بدون تغییر برنچ و اینا میتونیم ببینیم اون موقع توش چی بوده. فقط این که آدرس کامل فایل رو باید نوشت.
67- تمرین جامع هیستوری
68- قسمت اول جواب تمرین
69- قسمت دوم جواب تمرین
70-دوستان عزیزم
71- دستور git checkout
72- دستور git restore
73- سرزنش کردن با git blame
74- سرزنش کردن بصری
75- استفاده از git lens
76- تگ ها
برای دیدن تگ ها دستور git tag رو میتونیم بزنیم. برای اضافه کردن تگ وقتی مینویسیم git tag "esme_tag" رو جایی که HEAD هست اعمال میکنه.
میتونیم هش کامیت خاصی رو هم بنویسیم که برای اون بذاره. مثلا git tag v1.0 HEAD~4 که اسم v1.0 رو برای ۴ تا کامیت قبلی بذاره. برای
اضافه کردن توضیح به تگ هم میتونیم از  git tag -a v4.0 head~1 -m "this is for before" استفاده کنیم. با git tag -n میتونیم تگ ها رو با
پیغام ها ببینیم. با git tag -d "esme_tag" هم میتونیم تگی رو پاک کنیم.
77- تگ ها به صورت ویژوال
78- ذخیره سازی کامیت ها و main
79- توضیح git revert و reset
80- مبحث git revert
81- دستور git reset
82- مفهوم soft در git reset
83- مفهوم mixed در git reset
84- برگرداندن تغییراتش
85- دستور جالب git bisect
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل چهارم - Branch & Merge
86- برنچ چیست
87- توضیح main و master
88- مفهوم fast forward
89- ساخت برنچ
اگه اسم برنچی رو بخوایم عوض کنیم. میشه یه برنچ دیگه ساخت و قبلی رو پاک کرد. اما با دستور زیر راحت میشه اسمش رو تغییر داد.
git branch -m esme_ghabli esme_jadid
نکته ای که داره لازم نیست روی اون برنچ هم باشیم. مثلا من رو main هستم. میتونم اسم یه برنچ دیگه رو بدون این که برم روش تغییر بدم. مثلا
git branch -m bugfix fixbug باعث میشه که اسم برنچ bugfix به fixbug تغییر کنه. و رو همون main هم هستم. البته اگه اسم اولیه وجود نداشته
باشه بهم ارور میده.
90- دستور diff برای برنچ و switch
میشه با نوشتن git diff main feature/sms تفاوت این ۲ تا برنچ رو دید. خودش بین اسم دو تا برنچ .. گذاشته بود. اونو زدم کار کرد. اسپیس هم کار
کرد. میشه از فلگ --name-status و یا چیزای دیگه هم استفاده کرد.
91- دستور stash
حالت ساده استفاده ازش اینه که وقتی نمیخوایم کامیت کنیم با git stash یه جای موقت نگه میداریم و بعد با git stash pop بازیابیشون میکنیم.
با git stash push -am "my message" میتونم بهش بگم که فایلهای جدیدی که ساختم و تغییرات رو داخل استش پوش کنه و نگه داره که بعدا برش دارم.
اگه فایل جدیدی نبود و فقط تغییر دادیم که با -m میتونیم این کار رو بکنیم. اینجوری میتونیم چندین تا پوش هم بکنیم. برای دیدن استش هایی که داریم
میتونیم از دستور git stash list استفاده کنیم. حتی با نوشتن git stash show stash@{0} یا هر شماره ای که داره میتونیم ببینیم چی داره. و با
دستور git stash apply 0 میتونیم بهش بگیم که بره به اون حالت. برای دور ریختن هم میتونیم با git stash drop 0 یا شماره اش دراپش کنیم.
92- مرج fast forward و 3way merge
93- مرج fast forward
94- توضیح no ff
95- انجام no ff
تو حالتی که برنچ رو پیش بردیم و میخوایم حالا main رو باهاش ادغام کنیم و میتونه ff این کار رو انجام بده. اما ما نمیخوایم و میخوایم که یه کامیت
جدا بسازه که آمار این کامیت رو هم داشته باشیم که داشته با یه برنچ مرج میشده میتونیم از فلگ --no-ff استفاده کنیم. تفاوتش اینه که یه کامیت
اضافه تر میسازه و بعدا مشخصه که اینجا یه برنچ ساخته شده بوده که الان تو این کامیت مرج شده. نحوه نوشتنش با فرض این که فیچر اس ام اس رو چند
تا جلو بردیم و الان میخوایم main رو باهاش مرج کنیم. اول میریم رو برنچ main بعدش مینویسیم.
git merge --no-ff feature/sms
96- دستور revert و reset در no ff
97- لطف شما
98- کانفیگ کردن no ff
git config --global merge.ff no
این باعث میشه که کلا اگه خودمون --no-ff هم ننویسیم فست فوروارد نکنه. اگه خواستیم برگرده به حالت عادی که اگه ننوشتیم فست فوروارد کنه و اگه
بخوایم فست فوروارد نباشه براش بنویسیم --no-ff به جای no باید بنویسیم yes یعنی
git config --global merge.ff yes
سرچ کردن هم که همیشه هست.
99- مرج 3way
100- نظر شما
101- پیداکردن برنچ های مرج شده و نشده
git branch برای دیدن تمام برنچ ها
git branch --merged برای دیدن برنچ های مرج شده
git branch --no-merged برای دیدن برنچ های مرج نشده
102- مفهوم conflict در merge
103- چطوری abort کردن یک مرج
وسط مرج اگه کانفلیکت خوردیم و به هر دلیلی خواستیم بی خیال مرج کردن بشیم مینویسیم git merge --abort
104- نحوه revert و reset کردن merge
105- نوع squash
106- مثال squash
اگه بخوایم برنچ رو با یه برنچ دیگه که جدا پیش رفته مرج کنیم اما کامیت های تک تک برنچ دیگه رو نمیخوایم و فقط آخریش رو بخوایم، از اسکواش
استفاده میشه کرد. این شکلی که مثلا الان main رو با feature/sms میخوام مرج کنم. میرم رو main کارهام رو هم میتونم انجام بدم و کلی کامیت کنم.
بعد حالا میخوام کارهایی که تا الان تو فیچر اس ام اس بوده رو به این اضافه کنم اما مثلا ۱۰ تا کامیت اون ور کرده بودم که نمیخوام. فقط آخریش رو
میخوام. مینویسیم git merge --squash feature/sms و این طوری، برنچ فیچر اس ام اس رو که مرج نشده هست، کامیت آخرش رو میاره به کامیت فعلی مون
اضافه میکنه. البته احتمال کانفلیکت خوردن هم هست که خب باید درستش کنیم و بعد کامیت میکنه. اما نکته اش اینه که دیگه اون تک تک مراحل نیستند و
فقط یه کامیت هست. بعد از این کار دقت کنم که کدها ادغام شدند. اما اون برنچ مرج نشده هنوز سر جاش هست و اگه پاکش نکنیم بعدا احتمالا کسی
(یا خودم) فکر میکنه که کار ناقصی داریم و گیجمون میکنه. پس اگه از اسکواش استفاده کردیم برنچ رها شده رو هم بعدش پاک کنیم. در کل چیزیه که
کمتر استفاده میشه اما خلاصه اش همینا بود که نوشتم.
107- نحوه rebase
ریبیس برای اینه:  برنچ فیچر ساین آپ رو ده تا کامیت پیش بردیم. بعد برگشتیم main رو هم ۵ تا کامیت پیش بردیم. میخوایم دوباره خطی بشه پیشروی
اما اسکواش نکنیم. اینبار میریم رو برنچ فیچر ساین آپ و اونجا مینویسیم git rebase main. این طوری سعی میکنه بره به آخرین کامیت main و فیچر
ساین آپ رو از اونجا انگار شروع کرده. اگه کانفلیکتی رخ نده که مشکلی نیست و نقطه انشعاب به جای ۵ تا کامیت قبل از main میشه نقطه فعلی main.
اما اگه کانفلیکت رخ بده، باید درستش کنیم و بعد add ش کنیم و بعد هم به کارمون ادامه بدیم. اگه تو کامیت های بعدی کانفلیکت نباشه که میره
تا برسه به آخر. اما اگه باشه باید درستشون کنیم. برای ادامه دادنش هم دستور git rebase --continue رو مینویسیم و خود گیت کمک میکنه بهمون.
108- نحوه rebase با conflict
109- نحوه cherry pick
تو برنچ main هستم. برنچ فیچر لاگین کلی پیش رفته. اما هنوز مرج نشده. من به بخشی از کدهاش نیاز دارم. میتونم روی برنچ main که هستم بنویسم
git cherry-pick commit_hash و این طوری، کدهای اون کامیت خاص از اون برنچ به کدم اضافه میشه و یه کامیت جدید روی برنچ main ثبت میشه.
فقط حواسم باشه ممکنه تغییراتی داشته باشه روی فایل هایی که من هم تغییرات داشتم و کانفلیکت رخ بده که باید درستش کنم.
110- نحوه review merge
111- نحوه restore کردن از برنچ دیگر
اگه بخوایم فایلی رو از یه برنچ دیگه بیاریم، میتونیم با دستور زیر این کار رو بکنیم. مثلا الان رو برنچ main هستم. بعد از سورس میتونم اسم برنچ
دیگه ای رو بنویسم و اسم فایل مورد نظر رو یعنی مثلا
git restore --source=feature/store nefile.txt
اگه احیانا ارور هم داد ambiguous دو تا دش یادم باشه برای جدا کردن اسم فایل بذارم یعنی git restore --source=feature/store -- nefile.txt
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل پنجم - collaboration
112- مقدمه
113- فرآیند همکاری و collaboration
114- ساخت Git SSH Key در GitHub
115- کارکرد push و pull
116- لینک سایت
117- ساخت ریپازیتوری در گیت هاب
118- امکانات ریپازیتوری در گیت هاب
119- دعوت از دیگران
120- نحوه clone کردن پروژه
121- مفهوم origin/main
122- تمرین origin/main & HEAD
123- نحوه دیدن برنچ ها
با دستور git branch برنچ های لوکال رو میبینیم.
با دستور git branch -vv برنچ های لوکال و تفاوتشون با آنلاین رو میبینیم. این که چند تا جلوتر یا عقب تر هست. -v هم زدم نوشت اما اسم برنچ
آنلاین رو ننوشت.
اگه برنچی به صورت ریموت ساخته بشه. (یعنی از رو گیت هاب یا این که یکی دیگه بذاره و پوش کنه و من نداشته باشم) بعد از این که fetch کردیم
میتونیم با git branch -r از اون برنچ ها هم مطلع بشیم.
با دستور git remote میتونیم اسم اشاره گرهایی که برای ریموت درست کردیم رو ببینیم.
با دستور git remote -v هم با جزییات بیشتر مینویسه.
124- تفاوت pull و fetch
خلاصه: git pull = git fetch + git merge
git pull، اطلاعات رو از ریپازیتوری آنلاین میگیره و سعی میکنه merge هم بکنه. به خاطر همین ممکنه اون ارور های vscode رو ببینیم و کمی گیج بشیم.
البته الان دیگه دستم اومده. اما خلاصه اش اینه که git pull = git fetch + git merge  به خاطر همین اگه همیشه فچ کنم اول بهتره. چون اطلاعات رو
میگیرم اما خودش نمیاد مرج کنه. چون اگه کانفلیکت هم نخوره، خودش مرج میکنه که ممکنه یه کم گیج کننده باشه. پیشنهاد فعلی خودم اینه که اول
git fetch بزنم ببینم چه اتفاقی میفته. بعد git merge بزنم. یا بعدش دوباره git pull بزنم که مرج کنه. حالا در عمل شاید انقدر حرفه ای شدم که
همیشه یه ضرب git pull بزنم.
125- مفهوم درست pull
126- نحوه pull با rebase
اگه بخوایم 3way merge نزنیم و ریبیس کنیم، میتونیم دستور git pull --rebase رو بزنیم که این طوری ریبیس میکنه. فقط یادم باشه که اگه کانفلیکت
خوردم و رفعش کردم، برای ادامه دادن باید git rebase --continue رو بزنیم که ادامه بده کار رو.
127- پوش کردن تگ ها
به صورت پیش فرض تگ ها رو گیت هاب نمیرن. اگه بخوایم بفرستیم باید دستی خودمون بذاریم با دستور git push origin v1.0 که v1.0 اسم تگ لوکالمون
بود.
برای حذف تگ های آنلاین هم از دستور git push origin -d v1.0 استفاده میشه که اسم v1.0 اسم تگ آنلاینی هست که الان رو گیتهاب وجود داره.
128- ریلیزها در گیت هاب
مخصوص گیت هاب هست و برای گیت نیست. میتونیم به جای خاصی که رسیدیم و کامیت مناسبی هست و مثلا نسخه ای از برنامه هست که قابل ارایه هست، یه 
ریلیز بدیم که قابلیت دانلود اون ریلیز رو هم گیت هاب میده و یک سری امکانات که تو همین پروژه گیت هاب الکی یه ۲ تا ریلیز هم ساختم.
129- پوش کردن برنچ ها
برای پوش کردن یک برنچ جدید رو گیت هاب هم باید مشخص کنیم براش که بفرسته به این صورت. اول میریم رو برنچ جدید. کامیت هامون رو میکنیم. بعد که
میگیم git push ارور میده میگه نمیدونم کجا بذارم.
git push -u origin esme_branch
با دستور زیر هم میتونیم پاک کنیم برنچ ریموت رو
git push -d origin esme_branch
130- دریافت برنچ جدید
اول git fetch میزنیم که اطلاعات رو آپدیت کنه. بعد میتونیم با git branch -r ببینیم که برنچ های ریموت چی هستند. مثلا feature/login جدیده.
بعد باید لوکال یه برنچ بسازیم بر پایه اون که با یه دستور میتونیم هم بسازیم و هم بریم روش مثلا این طوری
git switch -C feature/login origin/feature/login که مثلا بهش گفتم یه برنچ به اسم فیچر لاگین بسازه بر اساس اوریجین فیچر لاگین و سوییچ کنه روش.
131- مفهوم و کارکرد pull request
132- پول رکوئست با کانفلیکت
133- ایشوها
134- لیبل ها در گیت هاب
135- مفهوم milestone
136- پروژه های متن باز
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ششم - دستکاری حرفه ای گذشته
137- مقدمه (فایل متنی بود. نوشته بود آپلود میشه فعلا نیومده)
138- علت تغییر گذشته (فایل متنی بود. نوشته بود آپلود میشه فعلا نیومده)
139- تغییر گذشته در کار تیمی (فایل متنی بود. نوشته بود آپلود میشه فعلا نیومده)
140- دانلود فایل های فصل (فایل متنی بود. نوشته بود آپلود میشه فعلا نیومده)
141- تحلیل پروژه فصل
142- دستورات دستکاری گذشته
143- مبحث مهم interactive rebasing
144- دستور reword
برای اینتراکتیو ریبیس کردن، کامیتی که میخوایم از اونجا شروع بشه نه یکی قبلیش رو انتخاب میکنیم. یا خودش رو با ~1 مینویسیم. مثلا فرض کنم
از کامیت 573a2dd میخوام تغییر بدم و خودش رو هم میخوام تغییر بدم مینویسیم. git rebase -i 573a2dd~1
145- دستور edit
146- دستور drop
147- دستور squash
148- تبدیل یک کامیت به دو کامیت
149- دستور fixup
150- دستور reorder
151- پاسخ تمرین در یک ویدئو
152- مبحث طلایی reflog
بحث جالبی بود. اگه یه گندی هم زدیم تو گیت تا یه مدتی که گاربیج کالکتور بیاد جمع کنه میتونیم برگردونیم به حالت قبلی. توضیح اضافه اینجا
نمیدم اگه لازم بود یا ویدیو رو ببینم یا سرچ کنم. دستورش git reflog هست. نکته خاصی هم نداره. میتونیم ریست کنیم به کامیتی که یک حالت خاص بود.
153- پایان دوره