فصل اول - شروع
کل فصل ۱ نکاتی که داشت رو نوشتم و دیدن دوباره اش وقت کشی ۱۰۰ درصد هست. برای یادگیری دیگه نبینم و همین پایینی ها رو بخونم و
خودم ور برم کافیه یا اگه لازم بود از اینجا فقط با کنترل اف سرچ کنم و پیدا کنم یا از اینترنت. اما دیدن دوباره فیلم تاکید 
میکنم وقت کشی هست.
1- سرعت پخش فیلم ها
2- مقدمه
3- پشتیبانی
4- چطوری از گیت استفاده کنیم
5- نصب گیت و vscode
6- چک کردن نصب گیت
تو لینوکس و مک، کامند + اسپیس سرچ رو باز میکنه. برای دیدن ورژن git --version رو میزنیم.
7- تنظیمات گیت
(این دستور رو نزنم. تا آخر بخونم بعد) برای دیدن تنظیماتی که تا حالا انجام شده، دستور git config --global -e رو میزنیم.
اما تو ادیتور vim که واقعا افتضاحه و دکمه backspace توش کار نمیکنه. خروج نداره، نمیشه تایپ کرد و غیره. برای این که ادیتور
رو عوض کنیم، قبل از این دستور میتونیم بنویسیم git config --global core.editor "code --wait" که بعد از
این با vscode بازش کنه و بشه مثل بچه آدم تغییرش داد. git config --global core.autocrlf true رو توی ویندوز مینویسیم و
git config --global core.autocrlf input رو توی مک و لینوکس مینویسیم که تنظیمات گیت برای تمام سیستم عامل ها یکپارچه بشه. 😒
حالا میتونم دستور git config --global -e رو بزنم که تنظیماتش رو ببینم. احتمالا e اول کلمه edit رو برداشتن.
8- استفاده از ترمینال قسمت 1
 با دستور touch yechizi.txt میشه یه فایل خالی ساخت تو ترمینال git bash. ولی تو cmd فرق داره. با دستور rm esme_file میتونیم
 پاکش کنیم. با clear هم تمیز میشه. البته تو cmd باید cls رو نوشت.
9- استفاده از ترمینال قسمت 2
ساخت دایرکتوری با دستور mkdir test هست. با cd میشه جابه جا شد. برای پاک کردن فولدر دستور rm جواب نمیده. باید بنویسیم
rmdir esme_directory تا پاک شه. البته اگه داخلش فایل باشه میگه که داخلش فایل هست و اول اون ها رو پاک کن بعد. اما میشه
دستور rm -rf esme_directory زد که خطرناکه و به طور ریکرسیو هر چی داخلش هست رو پاک میکنه. تو ریسایکل بین هم نمیره.
10- استفاده از ترمینال قسمت 3
با دستور echo میشه یه چیزی رو پرینت کرد. اگه چند تا کلمه باشن داخل دابل کوتیشن مینویسیم. برای ریختنش تو فایل با علامت بزرگتر
این کار رو میکنیم. اما پاک میکنه و append نمیکنه. برای append کردن دو تا علامت بزرگتر پشت سر هم میذاریم. متن داخل کوتیشن
هم نوشتم کار کرد و بدون کوتیشن هم حتی کار کرد. ولی حواسم باشه که عادت نکنم و بهتره که بذارم دابل کوتیشن رو. چون همه جا
کار نمیکنه. برای کپی کردن فایل، از دستور cp استفاده میکنیم. فایل مبدا و بعد فایل مقصد. برای انتقال از دستور mv استفاده
میکنیم. باز هم از مبدا به مقصد که مقصد فولدر هست. البته میتونیم اسم فایل هم بذاریم که در این صورت در حین انتقال، اسم فایل
رو هم عوض میکنه. یعنی اطلاعات داخل فایل قبلی ها میمونه، اما اسمش عوض میشه. که خب از همین برای تغییر نام یک فایل در پوشه
فعلی هم میشه استفاده کرد. برای دیدن همه فایل ها و فولدرها دستور ls. برای دیدن با جزییات بیشتر ls -a و برای دیدن جزییات
واقعی از ls -al استفاده میکنیم که میگه کی ساخته. کِی ساخته. سطح دسترسیش چیه. برای دیدن کارنت دایرکتوری هم دستور pwd
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل دوم - گیت مقدماتی
11- روند ذخیره تغییرات در گیت به چه صورت هست؟
توضحات جالبی بود. برای خودم دیگه به درد نمیخوره. اگه بخوام دوره بسازم میتونم ازش ایده بگیرم.
12- گیت چطوری گذشته رو ذخیره میکنه؟
13- مبحث git snapshot
14- مبحث staging area
15- بریم دست به کد بشیم!
16- نحوه کامیت کردن و برسی لاگ ها
17- دستور git add
18- صورت تمرین مرور مباحث
19- پاسخ ویدئویی تمرین به همراه نکات
از اول فصل ۲ تا اینجا به کار خودم خیلی نمیاد. جالب و مفهومی بود. اما برای گفتن به بقیه. برای خودم چیز جدیدی نداشتن.
20- امکان oneline و reverse
با دستور git log --oneline میتونیم دیگه اطلاعات جزیی رو نگیریم و راحت تر به لاگ ها دسترسی داشته باشیم.
با دستور git log --reverse هم میتونیم کامیت ها رو برعکس ببینیم. یعنی اولین کامیت رو اول نشون میده. همزمان هم میشه
هر دو تا رو نوشت و ترتیبشون هم فرقی نداره.
21- سوییچ های -a و -m در کامند کامیت
خیلی مهم نیست. اما اگه فایلی رو تغییر دادیم و میخوایم با یه دستور هم اضافه اش کنیم به stage area و هم فوری بعدش
کامیت بزنیم، میتونیم بنویسیم git commit -a -m "peygham" که خودش اول همه فایل های تغییر یافته رو به استیج اضافه میکنه
و با پیغامی که نوشتیم کامیت هم میکنه. میشه به طور خلاصه تر git commit -am "peygham" هم نوشت. نکته ای که داره فایل های
جدید رو اضافه نمیکنه. یعنی برای این که فایل های تغییر داده شده رو یه کامیت برای تغییراتشون بزنیم خوبه. برای فایل هایی
که بخوایم اضافه کنیم جداگانه باید git add رو بنویسیم.
22- اصول نوشتن کامیت ها
نکته ای که داشت، وقتی گیت کامیت خالی بدون -m میزد، تو vscode بعد از خط اول، ۲ تا اینتر زد و چیزهایی که نوشت اونا دیگه
نیومدن. در واقع بدنه کامیت هستن که توضیحات طولانی رو میشه اونجا نوشت که حالت عادی وقتی گیت لاگ میزنیم اذیت نکنه. اما
توضیح بیشتری راجع به اون کامیت اگه داریم میشه نوشت.
23- حذف فایل کامیت شده از پروژه
24- دستور git rm
وقتی یه فایلی رو پاک میکنیم، برای این که به گیت هم بفهمونیم بعدش باید بگیم git add esme_file که گیت بفهمه پاک شدن اون
فایل حالت جدیدی از استیجینگ اریا هست و بعد کامیتش کنیم. حالا اگه بخوایم خود گیت یه فایلی رو پاک کنه و به استیجینگ اریا
هم ببره، میتونیم این ۲ تا مرحله رو یکی کنیم. یعنی به جای این که فایل رو پاک کنیم و بعد بنویسیم git add file_e_paak_shode
به جاش تو یه مرحله مینویسیم git rm esme_file و این طوری خودش فایل رو پاک میکنه و به استیجینگ اریا هم میره. یعنی لازم نیست
دیگه برای اون فایل git add رو بنویسیم و یه مرحله کوتاه تر میشه. اما کامیت نمیکنه. چون شاید بخوایم اون فایل رو برگردونیم
و یا بخوایم تغییرات دیگه رو هم همراه با اون کامیت اعمال کنیم.
25- الگو در انتخاب فایل ها
جالب بود. در مورد کار با فایل ها و آدرس دهی بود. رو اونا مسلط بشم اینم حله. نکته جدیدی از گیت نداشت. مثل همون نامگذاری
فایل ها اینا هست که مثلا *.txt یعنی همه فایل های با پسوند txt در فولدر فعلی و یا */*/*.txt یعنی همه فایل ها با پسوند txt
در این فولدر و فولدرهای داخلیش و فولدرهای داخلی اونها.
26- حذف از ایندکس
جالب بود. برای درک مفهومی بهتر خوب بود. ولی خیلی هم خاص نبود و نکته ای نداشت.
27- نظر شما
28- تغییر نام با git mv
وقتی یه فایلی رو rename میکنیم، برای شناسوندن به گیت، باید بهش بگیم پاک کردن یک فایل رو به استیجینگ اریا اضافه کنه و ساخته
شدن فایل جدید رو هم به استیجینگ اریا اضافه کنه و دو تا فایل رو باید اضافه کنیم. بعد خودش با توجه به محتویات متوجه میشه که
عملی که انجام دادیم rename هست. برای راحتی کار میتونیم به گیت بگیم rename کنه که دیگه ما هم زیاد ننویسم. مثلا برای تغییر نام
فایل 1.txt به 2.txt میشه نوشت git mv 1.txt 2.txt که خودش رینیم میکنه و چون تو استیجینگ اریا بود، کافیه کامیتش کنیم بعد.
اگه از طریق سیستم عامل یک فایل رو rename کنیم که خب با دستور گیت انجام ندادیم و اونجا باید دو تا رو جداگانه add کنیم یا اگه
میشد با git add . یا git add *.py و این جور چیزا اضافه کنیم.
29- درک wd و sa و repo
wd ورکینگ دایرکتوری هست. sa استیجینگ اریا و repo هم ریپازیتوری. از نظر مفهومی خیلی ویدیو خوب و پرباری بود. خیلی جالب بود و
واقعا عالی توضیح داد. مجدد هم ببینم حتما فایده داره. هیچ کدی نزد و فقط توضیح بود. اما توضیح مفهومی و عالی تفاوت های حالت های
ترک نشده و استیج شده و کامیت شده.
30- دستور git status -s
خیلی توضحات باحالی داشت و جالب بود. اینجا دیگه نمینویسم باید کار کنم باهاش تا دستم بیاد. دیدن دوباره ویدیو هم بد نیست. اما
کار کردن با این دستور هست که باعث میشه خوب یاد بگیرم.
31- دستور مهم git diff
این ویدیو و بعدی، راجع به دستور git diff بود. با دستور git diff، تفاوت تمام فایل های تغییر یافته رو در ورکینگ دایرکتوری با
استیجینگ اریا بهمون میگه. اگه بخوایم برای یه فایل خاص رو ببینیم اسمش رو هم مینویسیم مثلا git diff test.py که تفاوت تمام فایل ها
رو دیگه نمیده. فقط همون فایل که ورکینگ دایرکتوری با استیجینگ اریا چه فرقی داره. تو ویدیو بعدی میگه که اگه بخوایم تفاوت
استیجینگ اریا با ریپازیتوری رو ببینیم از git diff --staged استفاده میکنیم که اگه فایل رو ننویسیم تفاوت تمام فایل های استیجینگ
اریا با ریپازیتوری رو میده و اگه بنویسیم فقط همون مورد رو.
32- دستور diff برای stage
33- عملیات git diff در vscode
راجع به کار کردن با قسمت سورس کنترل وی اس کد گفت که جالب بود. نوشتن خیلی فایده نداره. کار کنم دستم بیاد بهتره.
34- درخواست
35- نکته مهم difftool
36- تنظیمات difftool
این تغییرات رو انجام ندادم. به صورت پیش فرض vscode خودش تو قسمت سورس کنترل دائم git status رو اجرا میکنه و میتونیم به صورت
گرافیکی تغییرات تمام فایل ها رو ببینیم که خودم هم استفاده میکنم. حتی git diff --staged رو هم میشه از همون قسمت دید. اما این
ابزار difftool در vscode برای الان هست. ما با دستور git diff یا git diff --staged میتونیم مثلا ببینیم که فایلمون توی ۱۰۰ کامیت
قبل با ۱۰۲ کامیت قبلی چه تفاوتی داره. تو تنظیماتی که اینجا انجام داد، میتونیم بهش بگیم که ابزار پیش فرض نمایش diff وی اس کد
باشه که بعد وقتی بهش گفتیم vim و اینا رو باز نکنه برامون. کلا خیلی کم استفاده میشه همچین چیزی. اما خب به هر حال این توضیحات
رو نوشتم که بدونم چی هست. در حال حاضر باز هم به سیستمم اعمال نکردم.
37- دستور مهم git restore
جالب بود. توضیح git restore --staged بود که دقیقا برعکس git add هست. چیزی رو که به حالت staged بردیم برمیگردونه به حالت
unstaged و دستور git restore خالی که چیزی رو که تغییر دادیم و هنوز stage نشده رو میتونیم برگردونیم به حالت قبل از تغییرات
یعنی آخرین ورژن کامیت شده فعلی. جالب بود. با تمرین کردن بود که متوجه شدم چه طوری کار میکنه. اما دیدن فیلم هم بد نیست. حالا اگه
یه فایلی رو جدید اضافه کنیم، با git restore --staged میشه برش گردوند به حالت unstaged. اما دستور git restore روش کار نمیکنه.
چون تازه ایجاد شده و این فایل آخرین کامیت نداره. خوشبختانه دستور git restore باعث نمیشه که اون فایل پاک بشه. گیت کلا اون رو
ترک نمیکرده. اگه بخوایم فایل های اضافه رو پاک کنیم میشه از دستور git clean استفاده کرد که فایل های untaracked رو پاک میکنه.
منتهی خودش به ما هشدار میده. fatal. چون احتمالا با دستور rm سیستم میاد پاکش میکنه و دیگه قابل برگشتن نیست، به ما ارور میده
میگه که با هیچ آپشنی استفاده نکردی. مثلا میتونیم با -f بزنیم که git clean -f دیگه میاد هر چی آنترکد هست رو پاک میکنه و دیگه
قابل برگردوندن نیست. در واقع git clean -f file_name مثل rm file_name عمل میکنه. git clean -i هم زدم جالب بود. آپشن میده که
کامل خودش توضیح میده. مثلا میتونیم همه رو انتخاب کنیم. یا موردی ازمون بپرسه. یا فایل ها رو به ما نشون بده و انتخاب کنیم و یا
این که پترن بهش بدیم. بقیه آسون بودم تست کردم و جالب بود. اما پترن رو نتونستم درست بدم. خلاصه جالب بود اما چون خیلی کاربردی
نبود پی اِش رو نگرفتم.
38- پشت پرده واقعی git restore
خیلی جالب نبود. خودش هم میگفت باعث گیج شدن میشه. با همون ویدیو قبلی که متوجه شدم و توضیحات خودم که نوشتم ادامه بدم.
39- تمرین restore
تمرین جالبی بود. restore رو بهتر درک کردم. توضیحاتشم خوب بود.
40- مفهوم HEAD
چیزی که فهمیدم اینه که HEAD در واقع یه اشاره گر هست به آخرین کامیتی که کردیم. میتونیم بهش بگیم ۲ تا قبلی یا ۳ تا قبلی.
تو فصل برنچ کامل تر توضیح داده.
41- مفهوم و کاربرد HEAD
42- استفاده از git restore و فلگ source--
خیلی ویدیو جالب و مهمی بود. وقتی ما مینویسیم git restore esme_file و به دستور restore ورودی نمیدیم، خودش مرجعش رو میذاره
HEAD. پس در واقع مرجع داره و دیفالتش HEAD هست. اما ما میتونیم تعیین کنیم. مثلا میتونیم بنویسیم git restore --source=x esme_file
که x شماره کامیتی هست که قبلا انجام دادیم. مثلا تو ۴۰ تا کامیت قبلی یه فایلی رو پاک کرده بودیم، میتونیم این طوری برش گردونیم
بدون این که بقیه چیزها به هم بریزه. البته دقت کنم برای فایلی هست که پاکش کرده بودیم. اگر اسم فایلی رو بنویسیم که هنوز وجود داره،
فایل اون موقع رو میاره به اینجا و استیجینگ اریا و انگار که خودمون دستی فایل جدید رو تغییر دادیم. بعد خودمون تصمیم میگیریم که
چیکار کنیم. نکته مهم هم این که دقت کنم. تست نکردم اما اگه یه فایلی رو تغییر بدم در حال حاضر و در حال ترک باشه و به استیجینگ اریا
اضافه اش نکرده باشم، و بعد این مدلی restore کنم از قدیمی ها، قاعدتا یکیش از بین میره. چون من از تو ورکینگ دایرکتوری روش یه
تغییراتی اعمال کردم و هنوز وارد استیجینگ اریا نکردم. پس اگه یکی از حالت های قدیمی رو restore کنم تغییرات امروز من از بین میره.
خلاصه این که موقع restore کردن حواسم باشه و دقت کنم. نکته مهم اینه که اگه فقط بنویسیم git restore --source=x و فقط شماره کامیت رو
بنویسیم و بعدش فایلی ننویسیم، ارور میده میگه مسیر ندادی. خودم git restore --source=x * نوشتم خودش تمام ساختار رو برگردوند به
اون حالت و خیلی ها پاک شدند (چون رفته بودم به اولین کامیت D:) تفاوتش با ریست کردن این بود که وقتی git log میگرفتم لاگ ها رو هم
بهم نشون میداد. با git restore --source=x * که این بار x آخرین کامیت فعلی بود، هیچی برنگشت D: زدم git restore --source=x */*
و این بار فولدرها و فایلهای داخلی برگشتن. اما فایل های دایرکتوری ای که توش گیت رو اجرا کرده بودم برنگشت و اونا رو دونه دونه باید
مینوشتم. اما با گیت ریست دش دش هارد همه برمیگشت. خلاصه. موقع کار باهاش دقت کنم. نکته آخر این که اگه شماره کامیت رو نخوایم بنویسیم،
میشه با استفاده از هد هم به چند کامیت قبلی برگشت. مثلا git restore --source=HEAD~5 file_name یعنی برو file_name رو از ۵ تا کامیت
قبل از HEAD بیار. علامتش منها نیست تیلدا هست. کار کنم یاد میگیرم این نوشتن ها خیلی فایده نداره.
43-مفهوم فایل های .keep
اگه بخوایم یه فولدری بسازیم که گیت دنبالش کنه اما در حال حاضر فایلی نداریم که بذاریم و نمیخوایم فایل اصلی ای رو بذاریم، رایجه
که داخل اون فولدر یه فایل به اسم .keep میذارن. یعنی فولدرمون رو بسازیم و داخلش فایل .keep خالی بذاریم همه گیت کارها میدونن که اون
فایل برای این هدف بوده. نکته خاص دیگه ای نداشت این فیلم. . هم اول اسم فایل ها باعث میشه که هیدن باشن.
44- رفع ارور ambiguous
گفت اگه جایی این ارور رو خوردیم که گیت نمیشناسه حالا به خاطر شبیه بودن اسم فایل یا فولدر یا سورس یا هر چی هست، با دو تا دش میتونیم
جدا کنیم که بهش کمک کنیم مثلا اگه git restore --source=HEAD~5 file1.py گیر داد که اسم فایل file1.py برای من ambiguous است، با
نوشتن git restore --source=HEAD~5 -- file1.py بهش میفهمونیم چیزایی که سمت چپ هستند فایل نیستند (سورس و چیزای دیگه هستند) و چیزایی
که سمت راست هستند اسم فایل هستند. گفت فقط اینجا و برای دستور restore نیست. همه جا در گیت اینطوری هست. کلش همین بود و نوشتم و لازم
نیست دیگه فیلم رو ببینم.
45- دستور alias و کاربرد آن
جالب بود. اگه بخوایم خودمون دستوری به گیت اضافه کنیم و کاستومایزش کنیم، میتونیم. مثلا خودش برای unstage کردن یه دستور ساخت و نوشت
git config --global alias.unstage "restore --staged" این کار باعث میشه که تو فایل تنظیماتش داخل قسمت alias نوشته بشه که هر وقت ما
تو گیت نوشتیم unstage خودش به جاش از restore --staged استفاده کنه. یعنی از الان به بعد تو گیت من میتونم بنویسم git unstage file_name
و این طوری فایلی که تو حالت staged هست برمیگرده به حالت unstaged. خودم دستی تو فایلش اسم unstaged رو عوض کردم گذاشتم haghdashdefo
D: و دیدم که کار میکنه یعنی نوشتم git haghdashdefo file2.txt و فایلی که تو حالت staged بود رو به حالت unstage برد. خلاصه این که
خودمون میتونیم دستورات جدید برای راحتی کار تعریف کنیم. من برگردوندم به همون unstage و رو سیستم من هست. اما خودش گفت که تو دوره
استفاده نمیکنه. ولی چیز جالبی بود. alias های دیگه ای که ساختم. goal برای log --graph --oneline --all و oal برای log --oneline --all
46- دانلود فایل تمرین
47- تمرین restore
48- دستور git amend
اگه یه کامیتی کردیم اما یادمون اومد که یه تغییرات دیگه ای هم با این کامیت بوده و نمیخوایم کامیت جدا بزنیم، میتونیم
از دستور git commit --amend استفاده کنیم که روی آخرین کامیت دوباره کامیت میکنه. ما رو وارد ادیتور میکنه که یه پیغام براش بذاریم.
میتونیم با git commit --amend -m "peygham" همونجا بگیم و دیگه ما رو وارد ادیتور نکنه. و یا اگه پیغامش رو نمیخوایم عوض کنیم میتونیم 
از سوییچ --no-edit استفاده کنیم و بنویسیم git commit --amend --no-edit که دیگه پیغام جدید ندیم و وارد ادیتور هم نکنه ما رو. اما روی
همون کامیت قبلی اعمال کنه و کامیت جدید نسازه.
نکته مهم اینه که امند، دوباره کامیت میکنه و هشش هم عوض میشه. پس اگه لوکال بودم و همون لحظه خواستم تغییر بدم و کس دیگه ای به من وابسته
نبود میتونم استفاده کنم. در غیر این صورت ممکنه برای بقیه مشکل پیش بیاد.
49- دستور git show
با نوشتن git show commit_hash میتونیم ببینیم که تو یه کامیت چه تغییراتی رخ داده بود و چه زمانی بود و کی کامیت کرده بود. میتونیم بعدش
یه : هم بذاریم و بگیم که یه فایل خاص رو به ما نشون بده. مثلا git show 35x83s6:seen.txt که میاد فایل seen.txt اون کامیت رو به ما نشون میده.
50- دستور ls-tree
برای لیست کردن ساختار درختی پروژه با دستور git ls-tree commit_hash میتونیم ببینیم ساختار درختی پروژه در اون کامیت چه شکلی بوده.
مثلا git ls-tree head نشون میده که الان ساختار پروژه چه شکلی هست. و git ls-tree head~10 نشون میده که ساختار ۱۰ تا کامیت قبلی چه شکلی بوده.
خلاصه میتونیم هش شده کامیت رو هم بهش بدیم و ساختار اون زمان رو به ما میده. تو جوابی که میاره، اولش ۶ تا رقم هست که احتمالا همون سطح دسترسی
فایل یا فولدر هست. بعدش کلمه blob یا tree رو مینویسه. blob یعنی که اونی که جلوشه و در ادامه مینویسه فایل بوده و tree یعنی خودش یه ساختار
درختی دیگه داره. بعد از اون هش شده اون فایل یا اون درخت رو در اون زمان مینویسه. و اگه بخوایم ریزتر بررسیش کنیم، مثلا بخوایم ببینیم که یه
پوشه خاص چه فایل هایی داشته، میتونیم اون هش رو برداریم و دوباره بنویسیم git ls-tree oon_hashi_ke_copy_kardim و این طوری ساختار اون پوشه
رو به ما نشون میده و همین طوری میشه ادامه داد. در آخر هم اسمش رو مینویسه که blob بوده یعنی اسم فایل هست و اگه tree بوده یعنی اسم دایرکتوری
هست و ما میتونیم به این روش اسم فولدر یا فایلهایی که تو ۴۰ تا کامیت قبلی وجود داشتند و بعد پاک شدند رو هم پیدا کنیم و اگه لازم بود اونها
رو restore کنیم.
51- ساختار ذخیره فایل
طولانی و زیاد بود و فکر نکنم خیلی مهم باشه. با git ls-files، تمام فایل های ترک شده رو نشون میده و کلی آپشن داره. بنویسم git ls-files -h
هلپش رو میاره و اگه لازم شد همون موقع ازش استفاده کنم.
52- فایل .gitignore
لینک https://github.com/github/gitignore/tree/main رو معرفی کرد که فایل های گیت ایگنور برای پروژه های مختلف روش هست.
53- نکته مهم ignore کردن فایل های کامیت شده
اگه فایلی رو از قبل اضافه کردیم و گیت داره اون رو ترک میکنه، حالا اگه به گیت ایگنور اضافه اش کنیم باز هم گیت تغییراتش رو ثبت و کامیت هم
میکنه. برای این که دیگه این کار رو نکنه از دستور git rm --cached esme_file دقت کنم که اگه --cached رو نذارم هم از تو استیجیگ اریا ورمیداره
و هم دستور rm رو روش اجرا میکنه و فایل پاک میشه. اما با --cached از استیجینگ اریا ورمیداره اما فایل رو از ورکینگ دایرکتوری پاک نمیکنه.
54- دانلود فایل تمرین
55- تمرین جذاب و امنیتی gitignore
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل سوم - گیت پیشرفته
شروع از فصل ۳